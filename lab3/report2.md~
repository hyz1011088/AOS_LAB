# Lab3 erport

## [练习0]	填写已有实验

使用系统中到meld工具，针对lab1/lab2中更改过的文件(kern/mm/default_pmm.c、kern/trap/trap.c、kern/debug/kdebug.c)，进行代码更改。


## [练习1]	给未被映射的地址映射上物理页

【完成do_pgfault(mm/vmm.c)函数,给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在VMA的权限,同时需要注意映射物理页时需要操作内存控制结构所指定的页表,而不是内核的页表。注意:在LAB2 EXERCISE 1处填写代码。执行 make qemu 后,如果通过check_pgfault函数的测试后,会有“check_pgfault() succeeded!”的输出,表示练习1基本正确。】

一.实现过程：
```
   1. 由异常addr和mm->pgdir找到对应页表项page。
   2. 如果对应到页表项page存在，则根据addr和mm->pgdir将磁盘中相应的页换入page中，并建立page与addr之间的map;如果不存在，则分配一块物理内存，并实现该物理内存与addr之间的map。
   3. 最后设置该物理内存页是可交换的（与常驻内存相区别）。	

```

二.课程问题：

1.请描述页目录项(Pag Director Entry)和页表(Page Table Entry)中组成部分对ucore实现页替换算法的潜在用处。

```
   1. 页表项中到pte_p位标志着将页调入内存中到计算方式；
   2. 页替换算法需要使用到页表项中到驻留位等设置位；
   3. PTE_A与PTE_D位则可以用来记录是访问修改记录，可以用于选择换出的页。

```
2.如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事？

```
   1. 内核栈中保存现场，将EFLAGS，CS，EIP等进行压栈处理；
   2. 然后进行页访问异常处理例程;


```


## [练习2]	补充完成基于FIFO的页面替换算法

【完成vmm.c中的do_pgfault函数,并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_vistim函数。通过对swap的测试。注意:在LAB2 EXERCISE 2处填写代码。执行 make qemu 后,如果通过check_swap函数的测试后,会有“check_swap()	succeeded!”的输出,表示练习2基本正确。】

一.实现过程：
```
   1. 页面替换将页面从磁盘读入内存并建立和虚地址的链接后，调用swap_map_swappable函数，同时在在该函数中将该页面加入pra_list_head链表尾部；
   2. 缺页时实现FIFO算法，丢弃pra_list_head表头的页，该功能调用_fifo_swap_out_victim 函数以实现. 

```

二.课程问题：
   
如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：

```
   1. 现有的swap_manager框架是否足以支持在ucore中实现此算法？
      足以支持在ucore中实现此算法：
      页表项中有PTE_A与PTE_D位可以得到页是否被访问过，所以有两个标志位。在具体实现中需要将实际页面和页表项到对应关系，即在swap_manager访问标志位并进行修改。
 
   2. 需要被换出的页的特征是什么？
      访问位和修改位均为0，在表中位置与加入内存位置有关。

   3. 在ucore中如何判断具有这样特征的页?
      使用页表项到访问位和修改位的值进行查找。

   4. 何时进行换入和换出操作？
      换入：页访问异常page_default
      换出：内存分配的页面已满
	
```


## [实验分析]
本次实验是在实验二的基础上,借助于页表机制和实验一中涉及的中断异常处理机制,完成Page Fault异常处理和FIFO页替换算法的实现。

一. 主要学习之处：
1.给未被映射的地址映射上物理页:
    练习1中要求实现该算法。
2.完成基于FIFO的页面替换算法：
    练习2中要求实现该算法。

二. 未涉及知识：
全局置换算法、缺失率置换算法等。

